# 软件工程

《[代码中的软件工程](https://www.epubit.com/bookDetails?id=UB7d4a0286a92ee&typeName=%E6%90%9C%E7%B4%A2)》一书的配套教学资料


#### 介绍
[软件工程 —— 码农的自我修养](ppt/软件工程-码农的自我修养.pptx)

#### 工欲善其事必先利其器

* [工欲善其事必先利其器.pptx](ppt/工欲善其事必先利其器.pptx)
* 目录
```
1.编程神器 Visual Studio Code
1.1.下载安装 Visual Studio Code
1.2.VS Code 界面概览
1.3.VS Code 的基本配置
1.3.1.语言配置
1.3.2.自定义配置
1.4.VS Code 的基本使用
1.4.1.文件操作
1.4.2.工作区操作
1.4.3.无鼠标操作
1.4.4.代码注释和取消注释
1.5.VS Code 为什么能这么牛？
1.5.1.简洁而聚焦的产品定位贯穿始终
1.5.2.进程隔离的插件模型是定海神针
1.5.3.代码理解和调试——LSP和DAP两大协议居功至伟
1.5.4.以及集大成的 Remote Development
1.6.基于 VS Code 的 C/C++开发调试环境配置
1.6.1.下载安装 Visual Studio Code
1.6.2.安装 C/C++插件
1.6.3.安装 C/C++编译器和调试器
1.6.4.配置 Visual Studio Code 构建任务
1.6.5.配置 Visual Studio Code 调试环境
1.7.VS Code 远程开发环境配置
1.7.1.VS Code 远程开发环境概述
1.7.2.VS Code 远程开发环境 Remote - SSH 配置
1.7.3.VS Code 远程开发环境 Web Remote - code-server 配置
2.五大场景玩转 Git
2.1.Git 分布式版本控制系统
2.1.1.版本控制概述
2.1.2.Git诞生的历史
2.1.3.Git 的基本操作
2.2.场景一：Git 本地版本库的基本用法
2.2.1.安装Git
2.2.2.初始化一个本地版本库
2.2.3.查看当前 workspace 的状态
2.2.4.暂存更改的文件
2.2.5.把暂存区里的文件提交到仓库
2.2.6.场景一：Git 本地版本库用法参考
2.3.场景二：Git 远程版本库的基本用法
2.3.1.克隆远程版本库
2.3.2.远程版本库的基本命令简介
2.3.3.场景二：Git 远程版本库用法参考
2.4.Git 背后的设计理念
2.4.Git 背后的设计理念
2.5.场景三：团队项目中的分叉合并
2.5.1.团队项目的一个参考工作流程
2.5.2.分支的基本用法
2.5.3.场景三：团队项目工作流程参考
2.6.场景四：Git Rebase
2.7.场景五：Fork + Pull request
3.正则表达式十步通关
3.1.为什么使用正则表达式？
3.2.第一关：基本的字符串搜索方法
3.3.第二关：同时搜索多个字符串的方法
3.4.第三关：在匹配字符串时的大小写问题
3.5.第四关：通配符的基本用法
3.6.第五关：匹配具有多种可能性的字符集
3.7.第六关：贪婪匹配 vs. 懒惰匹配
3.8.第七关：一些特殊位置和特殊字符
3.9.第八关：使用捕获组复用模式
3.10.第九关：基本的字符串搜索替换方法
3.11.第十关：复用捕获组的方式进行替换
3.12.练习题

参考资料
```
#### 代码中的软件工程

* [工程化编程实战——代码中的软件工程.pptx](ppt/工程化编程实战——代码中的软件工程.pptx)
* [menu实验代码](src), [menu实验代码打包下载](ppt/menu_code.zip)
* https://github.com/mengning/menu
* 目录
```
4.简约而不简单——代码规范和代码风格
4.1.实验项目介绍
4.2.代码风格的原则：简明、易读、无二义性
4.3.编写高质量代码的基本方法
4.3.1.通过控制结构简化代码
4.3.2.通过数据结构简化代码
4.3.3.一定要有错误处理
4.3.4.性能优先策略背后隐藏的代价
4.3.5.拒绝修修补补要不断重构代码
4.3.6.编码过程中的团队合作
4.4.测试题
5.模块化软件设计
5.1.模块化的基本原理
5.2.模块化代码的基本写法
5.3.传统单体集中式架构与微服务架构
5.4.软件设计中的一些基本方法
5.4.1.KISS原则
5.4.2.使用本地化外部接口来提高代码的适应能力
5.4.3.保持设计结构和代码结构的一致性
5.5.测试题
6.可重用软件设计
6.1.消费者重用和生产者重用
6.2.接口的基本概念
6.2.1.软件模块接口举例
6.2.2.微服务接口举例
6.2.3.接口与耦合度之间的关系
6.2.4.同步接口和异步接口
6.3.可重用软件模块的接口设计范例
6.3.1.通用Linktable模块的接口设计
6.3.2.给Linktable增加Callback方式的接口
6.3.3.进一步改进Linktable的Callback方式的接口
6.4.通用接口定义的基本方法
6.4.1.参数化上下文
6.4.2.移除前置条件
6.4.3.简化后置条件
6.5.测试题
7.可重入函数与线程安全
7.1.线程的基本概念
7.2.函数调用堆栈
7.3.可重入函数
7.4.什么是线程安全？
7.5.Linktable软件模块的线程安全分析
8.工程化编程实战总结
8.1.menu子系统的可重用接口设计
8.2.Makefile工程文件
8.3.带参数的复杂命令函数接口的写法
8.4.看待软件质量的几个不同角度
8.5.编程的基本方法和原则
参考资料
```
#### 从分析到设计的基本方法

* [从需求分析到软件设计.pptx](https://gitee.com/mengning997/se/raw/master/ppt/%E4%BB%8E%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E5%88%B0%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1.pptx)
* 目录
```
9.获取需求的主要方法
9.1.什么是需求？
9.2.为什么需求非常重要？
9.3.获取需求的主要困难
9.4.有哪些类型的需求？
9.5.有哪些和需求相关的人员？
9.6.获取需求的主要方法
9.7.高质量的需求是什么样子？
9.7.1.便于验证的需求是高质量的
9.7.2.解决掉内在冲突的需求是高质量的
9.7.3.高质量需求的典型特征
9.8.绘图工具VS Code + draw.io
9.8.1.在线绘图工具draw.io
9.8.2.安装VS Code和draw.io插件
9.8.3.快速入门VS Code+draw.io画图
10.对需求进行分析和建模
10.1.需求分析的两类基本方法
10.2.用例建模（Use Case Modeling）
10.2.1.什么是用例（Use Case）？
10.2.2.用例的三个抽象层级
10.2.3.用例建模的基本步骤
10.2.4.准确提取用例的基本方法
10.2.5.用例图的基本画法
10.3.业务领域建模（Domain Modeling）
10.3.1.面向对象分析涉及的基本概念
10.3.2.业务领域建模的基本步骤
10.3.3.头脑风暴的具体做法
10.3.4.业务领域概念分类的方法
10.4.关联类及其关系数据模型
10.4.1.关联类及其UML类图画法
10.4.2.关联类的面向对象设计与实现
10.4.3.关联类的关系数据模型
10.5.关系数据的MongoDB数据建模
10.5.1.MongoDB简介
10.5.2.一对多关系建模的三种基础方案
10.5.3.反范式设计
10.5.4.MongoDB数据建模总结
10.6.业务概念原型
11.从需求分析到软件设计
11.1.敏捷统一过程
11.1.1.瀑布模型
11.1.2.统一过程（Unified Process）
11.1.3.敏捷统一过程的计划阶段
11.1.4.敏捷统一过程的增量阶段
11.2.对象交互建模（Object Interaction Modeling）
11.2.1.对象交互建模的基本步骤
11.2.2.找出关键步骤进行剧情描述（scenario）
11.2.3.将剧情描述（scenario）转换成剧情描述表（scenario table）
11.2.4.将剧情描述表转换成时序图的基本方法
11.2.5.从分析时序图到设计时序图
11.2.6.完整的“借书”用例对象交互建模
11.3.形成软件设计方案的基本方法
11.3.1.设计类图 vs. 分析类图
11.3.2.形成设计类图的基本步骤
11.3.3.形成软件设计方案的基本方法
参考资料
```

#### 软件科学基础概论

* [软件科学基础概论.pptx](https://gitee.com/mengning997/se/raw/master/ppt/%E8%BD%AF%E4%BB%B6%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%A6%82%E8%AE%BA.pptx)
* 目录

```
12.软件是什么？
12.1.软件的基本构成元素
12.1.1.对象（Object）
12.1.2.函数和变量/常量
12.1.3.指令和操作数
12.1.4.0和1是什么？
12.2.软件的基本结构
12.2.1.顺序结构
12.2.2.分支结构
12.2.3.循环结构
12.2.4.函数调用框架
12.2.5.继承和对象组合
12.3.软件中的一些特殊机制
12.3.1.回调函数
12.3.2.多态
12.3.3.闭包
12.3.4.异步调用
12.3.5.匿名函数
12.4.软件的内在特性
12.4.1.前所未有的复杂度
12.4.2.抽象思维 vs. 逻辑思维
12.4.3.唯一不变的就是变化本身
12.4.4.难以达成的概念完整性和一致性
13.软件设计模式初步
13.1.什么是设计模式？
13.1.1.设计模式一词的来源
13.1.2.设计模式的优点
13.1.3.设计模式的含义和构成
13.2.设计模式的分类
13.3.常用的设计模式
13.4.观察者模式举例
13.5.设计模式背后的设计原则
13.5.1.开闭原则（Open Closed Principle，OCP）
13.5.2.Liskov替换原则（Liskov Substitution Principle，LSP）
13.5.3.依赖倒置原则（Dependence Inversion Principle，DIP）
13.5.4.单一职责原则（Single Responsibility Principle，SRP）
13.5.5.迪米特法则（Law of Demeter，LoD）
13.5.6.合成复用原则（Composite Reuse Principle，CRP）
13.5.7.反思设计模式的根基
14.常见的软件架构举例
14.1.三层架构
14.2.MVC架构
14.2.1.什么是MVC？
14.2.2.MVC模式
14.2.3.MVC架构
14.3.MVVM架构
14.3.1.什么是MVVM？
14.3.2.Vue.js的基本用法
14.3.3.Vue.js背后MVVM模型
15.软件架构风格与描述方法
15.1.构建软件架构的基本方法
15.2.软件架构风格与策略
15.2.1.管道-过滤器
15.2.2.客户-服务
15.2.3.P2P
15.2.4.发布-订阅
15.2.5.CRUD
15.2.6.层次化
15.3.软件架构的描述方法
15.3.1.分解视图
15.3.2.依赖视图
15.3.3.泛化视图
15.3.4.执行视图
15.3.5.实现视图
15.3.6.部署视图
15.3.7.工作分配视图
16.什么是高质量软件？
16.1.软件质量的三种视角
16.1.1.软件质量的含义
16.1.2.产品视角下的软件质量
16.1.3.过程视角下的软件质量
16.1.4.价值视角下的软件质量
16.2.几种重要的软件质量属性
16.2.1.易于修改维护（Modifiability）
16.2.2.良好的性能表现（Performance）
16.2.3.安全性（Security）
16.2.4.可靠性（Reliability）
16.2.5.健壮性（Robustness）
16.2.6.易用性（Usability）
16.2.7.商业目标（Business goals）
参考资料
```

#### 软件危机的前生后世


```

17.软件危机
17.1.软件危机产生背景
17.2.有关软件危机的争论
18.软件过程模型
18.1.软件的生命周期概述
18.2.瀑布模型
18.3.原型化的瀑布模型
18.4.V模型
18.5.分阶段的增量和迭代开发过程
18.6.螺旋模型
19.PSP和TSP
19.1.个体和团队
19.2.个体软件过程PSP
19.2.1.PSP0
19.2.2.PSP0.1
19.2.3.PSP1
19.2.4.PSP1.1
19.2.5.PSP2
19.2.6.PSP2.1
19.2.7.PSP3
19.3.团队软件过程TSP
19.3.1.团队概述
19.3.2.TSP概述
19.3.3.TSP的基本原理
19.3.4.TSP的基本工作方法
20.CMM/CMMI
20.1.CMM/CMMI简介
20.2.CMM/CMMI的作用
20.3.CMM/CMMI的主要内容
20.4.CMMI评估过程
21.敏捷方法
21.1.敏捷方法产生的背景
21.2.敏捷软件开发宣言及所遵循的原则
21.3.Scrum敏捷开发方法
22.DevOps
22.1.什么是DevOps？
22.2.DevOps和敏捷方法
22.3.DevOps和精益原则
22.4.DevOps和全栈自动化
参考文献
```



